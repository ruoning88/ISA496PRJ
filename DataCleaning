library(readxl)
library(dplyr)
library(stringr)
library(tidyverse)
library(DMwR)
library(ggplot2)
box <- read_excel("Box Dataset.xlsx",skip=1,col_names = TRUE,col_types = 
                    c(rep("numeric",8),"date","numeric","text","text",rep("numeric",8),
                      "text","numeric","numeric",rep("text",3),"numeric","numeric",rep("text",31)))

#### Delete Blank Columns ####
box <- box %>% select_if(~!all(is.na(.)))

#### Delete IDs , Derived (Repetitive) Variables ####
box <- box %>% select(-c(`Order #`,`Spec #`,`Customer Code`,`Fold Length`,`Length/Depth`,`Square Footage per piece`))

#### Convert to factors ####
box$Machine <- as.character(box$Machine)
i <- sapply(box, is.character)
box[i] <- lapply(box[i], as.factor)

#### Target Variable ####
box$Cost1 <- box$`Actual Setup Hours`+box$`Actual Run Hours`-box$`Standard Setup Hours`- box$`Standard Run Hours`

#### Date Variable must be broken down into numbers ####
box$prodmonth <- as.numeric(substring(as.character(box$LAST_WORKED),6,7))
box <- box[,-7]

#### Summary Statistics ####
source("data summary.R")
options(scipen=999)
data.summary(box)

#### Omit 64 observations with missing metrics (Variables with the same pattern of NAs entail 
####the same information, delete them to avoid multiculinearity)####
box <- box[-which(is.na(box$`# per Unit`)),]

#### Impute N (No) to YES/NO indicators ####
box2 <- box[,22:46]
box1 <- box[,c(1:21,47,48)]
i <- sapply(box2, is.factor)
box2[i] <- lapply(box2[i], as.character)
for (i in 1:25) {
  box2[which(is.na(box2[,i])),i]<- "N"
}
i <- sapply(box2, is.character)
box2[i] <- lapply(box2[i], as.factor)
box <- cbind(box1,box2)
##SNOW2SLIDES only has one level, eliminate it
box <- box %>% select(-`Snow 2 Sides`)

#### Imput missing CuttingDie ####
box$`Cutting Die #` <- as.character(box$`Cutting Die #`)
box$`Cutting Die #`[which(is.na(box$`Cutting Die #`))] <- "UN"
box$`Cutting Die #` <- as.factor(box$`Cutting Die #`)

#### Missing Value Flags ####
box$M_Ink<- as.factor(ifelse(is.na(box$`# of Inks`),1,0))

#### KNN Imputation for Numeric Variables ####
box.nums <- box %>% select_if(is.numeric) 
box.cats <- select_if(box,negate(is.numeric))
box.nums <- knnImputation(box.nums,meth="median",k=20)
boxFinal <- cbind(box.nums,box.cats)

#### Factor Level Collasping ####
boxFinal$Style <- recode_factor(boxFinal$Style, "FOLL"="OTH", "FOLW"="OTH","FOL"="OTH", 
                                "HSCL"="OTH","HSCW"="OTH","RSCM"="RSC","RSCW"="RSC","HSC"="OTH",
                                "HSCL-DC"="OTH","HSCL2UP"="OTH","HSCW-DC"="OTH",
                                "RSCL-BID"="RSCL", "RSCL-DC"="RSCL", "RSCMD1"="RSC",
                                  "RSCMD2"="RSC","RSCMD3"="RSC","RSCW-BID"="RSC","RSCW-DC"="RSC",
                                "RSCWXF"="RSC","TUBELFLANGED"="OTH", "SPECIAL BOX"="OTH","D/C"="OTH")

boxFinal$`Cutting Die #` <- as.character(boxFinal$`Cutting Die #`)
boxFinal$`Cutting Die #`[which(boxFinal$`Cutting Die #` != "CR12152C" & boxFinal$`Cutting Die #` != "UN")] <- "Others"
boxFinal$`Cutting Die #` <- as.factor(boxFinal$`Cutting Die #`)

boxtest <-boxFinal
boxtest$Grade <- as.character(boxtest$Grade )
grade <- unique(as.factor(str_replace_all(substring(boxtest$Grade,1,4),"[^[:alnum:]]", "")))
# First Collaspe factors according to the first 3-4 letters
for(i in 1:length(grade)) {
sch <- as.character(grade[i])
index <- startsWith(boxtest$Grade,sch)
boxtest$Grade[index] <- sch
}
boxtest$Grade <- as.factor(boxtest$Grade )
# Collaspe even more so that the occurence of each factor level is greater than 10% of the total rows in this dataset
boxtest$Grade <- recode_factor(boxtest$Grade, "ROCK"="48C", "200B"="200", "200C"="200",
                               "26B"="26", "26C"="26","275B"="275", "275C"="275","29B"="29",
                               "29C"="29", "44B"="44", "44C"="44", "44K"="44","55C"="55",
                               "55EB"="55","32B"="32","32C"="32","32E"="32")
boxtest$Grade <- recode_factor(boxtest$Grade, "26"="OTH","29"="OTH","55"="OTH","250C"="OTH",
                               "350B"="OTH", "400B"="OTH", "40C"="OTH", "450B"="OTH","48BC"="OTH",
                               "51BC"="OTH","71BC"="OTH", "82BC"="OTH","Non"="OTH","Pre"="OTH",
                               "V3C"="OTH","275"="OTH","44"="40","48C"="40")
boxFinal <- boxtest

boxFinal$Flute <- recode_factor(boxFinal$Flute, "BC"="B", "E"="B","EB"="B")
boxFinal$`Glue Joint` <- recode_factor(boxFinal$`Glue Joint`, "Glued 1 3/8\""="Glued")
boxFinal$`Product Code` <- recode_factor(boxFinal$`Product Code`, "MARTI"="WRDFG")
data.summary(boxFinal)

#### Target Variable Transformation
## We don't need the first 4 columns anymore > already combined them and created our target varibale Cost1
boxFinal <- boxFinal[,-c(1:4)]
##Our target varibale is extremely right skewed. In order to model it, we have to normalize the distribution
boxFinal$Cost1log <- log10(boxFinal$Cost1 + 1 - min(boxFinal$Cost1))
ggplot()+geom_histogram(data=boxFinal,aes(x=Cost1),binwidth=0.01)
outliers <- boxFinal$Cost1[which(boxFinal$Cost1>1)]

#### Create Dummy Variables ####
boxFinal$`HH, Attachments` <- as.character(boxFinal$`HH, Attachments`)
boxFinal$`HH, Attachments`[which(boxFinal$`HH, Attachments`=="1")] <- "Y"
boxFinal$`HH, Attachments` <- as.factor(boxFinal$`HH, Attachments`)
box.nums <- boxFinal %>% select_if(is.numeric) 
box.cats <- select_if(boxFinal,negate(is.numeric))
dummies <- model.matrix( ~.,data=box.cats)
dummies <- as.data.frame(dummies)
dummies <- dummies[,-1]
dummies <- lapply(dummies,factor)
dummies <- as.data.frame(dummies)
box <- cbind(box.nums,dummies)
rm(boxtest,boxFinal,box.cats,dummies)

#### Checking Colinearity ####
M<-cor(box.nums)
library(corrplot)
corrplot(M,method="number") ##No Big Colinearity Problem. 
write.csv(box,file="BoxCleaned.csv", row.names = FALSE)

#### Training/Validation Partition ####
index<-sample(1:nrow(box), size=round(0.75*nrow(box)))
training <- box[index,]
validation <- box[-index,]
